AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Photo album stack (buckets, Lambdas, API Gateway). Minimal template for assignment step 7.
  Creates photo storage bucket, static site bucket, two Lambdas (index + search),
  API Gateway with /photos (S3 proxy) and /search (Lambda proxy), plus required IAM.

Parameters:
  PhotosBucketName:
    Type: String
    Default: cc-hw3-b2-photos
    Description: S3 bucket for storing photos (PUT triggers index Lambda).
  FrontendBucketName:
    Type: String
    Default: cc-hw3-b1-frontend
    Description: S3 bucket for static website hosting.
  ApiStageName:
    Type: String
    Default: prod
  OpenSearchEndpoint:
    Type: String
    Default: search-photos-rjpsl5liewh6itrngz2eput4am.us-east-1.es.amazonaws.com
    Description: OpenSearch endpoint hostname (no protocol).
  OpenSearchIndex:
    Type: String
    Default: photos
  LexBotId:
    Type: String
    Default: PIFZCZXUFU
  LexBotAliasId:
    Type: String
    Default: YCK6WUL81O
  LexLocale:
    Type: String
    Default: en_US

Resources:
  PhotosBucket:
    Type: AWS::S3::Bucket
    DependsOn: S3ToIndexPermission
    Properties:
      BucketName: !Ref PhotosBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:Put
            Function: !GetAtt IndexLambda.Arn

  PhotosBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref PhotosBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: PublicReadPhotos
            Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource: !Sub "${PhotosBucket.Arn}/*"

  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref FrontendBucketName
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: PublicReadFrontend
            Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource: !Sub "${FrontendBucket.Arn}/*"

  IndexLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: IndexLambdaPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:HeadObject
                Resource: !Sub "${PhotosBucket.Arn}/*"
              - Effect: Allow
                Action:
                  - rekognition:DetectLabels
                Resource: "*"
              - Effect: Allow
                Action:
                  - es:ESHttpPost
                Resource: "*"

  SearchLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SearchLambdaPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - es:ESHttpGet
                  - es:ESHttpPost
                Resource: "*"
              - Effect: Allow
                Action:
                  - lex:RecognizeText
                Resource: "*"

  IndexLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: cc-hw3-lf1-index-photos
      Handler: lambda_function.lambda_handler
      Runtime: python3.12
      Timeout: 30
      Role: !GetAtt IndexLambdaRole.Arn
      Environment:
        Variables:
          OPENSEARCH_ENDPOINT: !Ref OpenSearchEndpoint
          INDEX: !Ref OpenSearchIndex
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import urllib.parse
          from datetime import datetime
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest

          region = os.getenv("AWS_REGION", "us-east-1")
          service = "es"
          credentials = boto3.Session().get_credentials()
          rekognition = boto3.client("rekognition")
          s3 = boto3.client("s3")
          OPENSEARCH_ENDPOINT = os.getenv("OPENSEARCH_ENDPOINT")
          INDEX = os.getenv("INDEX", "photos")

          def send_to_opensearch(document):
              url = f"https://{OPENSEARCH_ENDPOINT}/{INDEX}/_doc"
              request = AWSRequest(
                  method="POST",
                  url=url,
                  data=json.dumps(document),
                  headers={"Content-Type": "application/json"},
              )
              SigV4Auth(credentials, service, region).add_auth(request)
              session = boto3.session.Session()
              http = session._session.create_client(
                  service_name="es",
                  region_name=region,
                  endpoint_url=f"https://{OPENSEARCH_ENDPOINT}",
              )._endpoint.http_session
              response = http.send(request.prepare())
              return response.status_code, response.text

          def get_custom_labels(bucket, key):
              try:
                  head = s3.head_object(Bucket=bucket, Key=key)
                  metadata = head.get("Metadata", {}) or {}
                  raw = metadata.get("customlabels") or metadata.get("customLabels")
                  if not raw:
                      return []
                  return [label.strip() for label in raw.split(",") if label.strip()]
              except Exception as e:
                  print(f"Failed to read custom labels: {e}")
                  return []

          def lambda_handler(event, context):
              print("Event:", event)
              bucket = event["Records"][0]["s3"]["bucket"]["name"]
              key = urllib.parse.unquote_plus(event["Records"][0]["s3"]["object"]["key"])
              custom_labels = get_custom_labels(bucket, key)
              rekog_resp = rekognition.detect_labels(
                  Image={"S3Object": {"Bucket": bucket, "Name": key}},
                  MaxLabels=10,
              )
              detected_labels = [label["Name"] for label in rekog_resp["Labels"]]
              combined = []
              for label in custom_labels + detected_labels:
                  if label not in combined:
                      combined.append(label)
              document = {
                  "objectKey": key,
                  "bucket": bucket,
                  "createdTimestamp": datetime.utcnow().isoformat(),
                  "labels": combined,
              }
              status, text = send_to_opensearch(document)
              print("OpenSearch response:", status, text)
              return {"statusCode": 200, "body": json.dumps("Done")}

  SearchLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: cc-hw3-lf2-search-photos
      Handler: lambda_search.lambda_handler
      Runtime: python3.12
      Timeout: 30
      Role: !GetAtt SearchLambdaRole.Arn
      Environment:
        Variables:
          OPENSEARCH_ENDPOINT: !Ref OpenSearchEndpoint
          INDEX: !Ref OpenSearchIndex
          LEX_BOT_ID: !Ref LexBotId
          LEX_BOT_ALIAS_ID: !Ref LexBotAliasId
          LEX_LOCALE: !Ref LexLocale
      Code:
        ZipFile: |
          import json
          import os
          import uuid
          import boto3
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest

          REGION = os.getenv("AWS_REGION", "us-east-1")
          SERVICE = "es"
          OPENSEARCH_ENDPOINT = os.getenv("OPENSEARCH_ENDPOINT")
          INDEX = os.getenv("INDEX", "photos")
          LEX_BOT_ID = os.getenv("LEX_BOT_ID")
          LEX_BOT_ALIAS_ID = os.getenv("LEX_BOT_ALIAS_ID")
          LEX_LOCALE = os.getenv("LEX_LOCALE", "en_US")

          session = boto3.Session()
          credentials = session.get_credentials()
          lex = boto3.client("lexv2-runtime", region_name=REGION)

          def search_opensearch(keywords):
              if keywords:
                  must_clauses = [{"match": {"labels": kw}} for kw in keywords]
                  query = {"query": {"bool": {"must": must_clauses}}}
              else:
                  query = {"query": {"match_all": {}}}
              url = f"https://{OPENSEARCH_ENDPOINT}/{INDEX}/_search"
              request = AWSRequest(
                  method="GET",
                  url=f"{url}?size=100",
                  data=json.dumps(query).encode(),
                  headers={"Content-Type": "application/json"},
              )
              SigV4Auth(credentials, SERVICE, REGION).add_auth(request)
              http = session._session.create_client(
                  service_name="es",
                  region_name=REGION,
                  endpoint_url=f"https://{OPENSEARCH_ENDPOINT}",
              )._endpoint.http_session
              response = http.send(request.prepare())
              body = response.text
              if response.status_code != 200:
                  raise RuntimeError(f"OpenSearch error {response.status_code}: {body}")
              return json.loads(body)

          def extract_keywords_with_lex(query_text):
              if not LEX_BOT_ID or not LEX_BOT_ALIAS_ID:
                  return None
              try:
                  resp = lex.recognize_text(
                      botId=LEX_BOT_ID,
                      botAliasId=LEX_BOT_ALIAS_ID,
                      localeId=LEX_LOCALE,
                      sessionId=str(uuid.uuid4()),
                      text=query_text,
                  )
                  slots = resp.get("sessionState", {}).get("intent", {}).get("slots", {}) or {}
                  keywords = []
                  for slot in slots.values():
                      if not slot:
                          continue
                      value = slot.get("value", {}).get("interpretedValue")
                      if value:
                          keywords.extend(
                              [w.strip() for w in value.replace(" and ", ",").split(",") if w.strip()]
                          )
                  return keywords or None
              except Exception as e:
                  print(f"Lex error: {e}")
                  return None

          def fallback_keywords(query_text):
              parts = [p.strip() for p in query_text.replace(" and ", ",").split(",")]
              keywords = []
              for part in parts:
                  if part:
                      keywords.extend(part.split())
              seen = set()
              ordered = []
              for kw in keywords:
                  if kw.lower() not in seen:
                      seen.add(kw.lower())
                      ordered.append(kw)
              return ordered

          def lambda_handler(event, context):
              q_params = event.get("queryStringParameters") or {}
              query_text = q_params.get("q") if isinstance(q_params, dict) else None
              if not query_text:
                  return {"statusCode": 400, "body": json.dumps({"message": "Missing query param q"})}
              if query_text.strip() == "*":
                  keywords = []
              else:
                  keywords = extract_keywords_with_lex(query_text) or fallback_keywords(query_text)
              os_resp = search_opensearch(keywords)
              hits = os_resp.get("hits", {}).get("hits", [])
              results = []
              for hit in hits:
                  source = hit.get("_source", {})
                  results.append(
                      {
                          "objectKey": source.get("objectKey"),
                          "bucket": source.get("bucket"),
                          "labels": source.get("labels", []),
                          "createdTimestamp": source.get("createdTimestamp"),
                      }
                  )
              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": "application/json",
                      "Access-Control-Allow-Origin": "*",
                  },
                  "body": json.dumps({"results": results}),
              }

  S3ToIndexPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref IndexLambda
      Principal: s3.amazonaws.com
      SourceArn: !Sub "arn:aws:s3:::${PhotosBucketName}"

  ApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: photo-album-api

  ApiGatewayS3Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiGatewayS3Put
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub "${PhotosBucket.Arn}/*"

  SearchResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: search

  PhotosResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: photos

  SearchMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref SearchResource
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SearchLambda.Arn}/invocations
      MethodResponses:
        - StatusCode: 200

  PhotosPutMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref PhotosResource
      HttpMethod: PUT
      AuthorizationType: NONE
      ApiKeyRequired: true
      RequestParameters:
        method.request.querystring.objectKey: true
        method.request.header.x-amz-meta-customLabels: false
      Integration:
        Type: AWS
        IntegrationHttpMethod: PUT
        Credentials: !GetAtt ApiGatewayS3Role.Arn
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:s3:path/${PhotosBucketName}/{objectKey}
        RequestParameters:
          integration.request.path.objectKey: method.request.querystring.objectKey
          integration.request.header.x-amz-meta-customLabels: method.request.header.x-amz-meta-customLabels
      MethodResponses:
        - StatusCode: 200

  PhotosOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref PhotosResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,PUT,OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,x-api-key,x-amz-meta-customLabels'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true

  SearchOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref SearchResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,x-api-key'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - SearchMethod
      - PhotosPutMethod
      - PhotosOptionsMethod
      - SearchOptionsMethod
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: !Ref ApiStageName

  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Enabled: true
      Name: photo-album-api-key
      StageKeys:
        - RestApiId: !Ref ApiGatewayRestApi
          StageName: !Ref ApiStageName

  UsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Properties:
      UsagePlanName: photo-album-usage-plan
      ApiStages:
        - ApiId: !Ref ApiGatewayRestApi
          Stage: !Ref ApiStageName

  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref UsagePlan

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SearchLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*

Outputs:
  PhotosBucketOut:
    Description: Photos bucket name
    Value: !Ref PhotosBucketName
  FrontendBucketOut:
    Description: Frontend bucket name
    Value: !Ref FrontendBucketName
  FrontendWebsiteURL:
    Description: Public website URL for the frontend bucket
    Value: !Sub "http://${FrontendBucketName}.s3-website-${AWS::Region}.amazonaws.com"
  ApiInvokeURL:
    Description: Invoke URL for the deployed API stage
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/${ApiStageName}"
  ApiKeyId:
    Description: API Gateway API Key ID
    Value: !Ref ApiKey
